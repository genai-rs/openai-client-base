/*
 * OpenAI API
 *
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 *
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

/// RealtimeServerEventInputAudioBufferTimeoutTriggered : Returned when the Server VAD timeout is triggered for the input audio buffer. This is configured with `idle_timeout_ms` in the `turn_detection` settings of the session, and it indicates that there hasn't been any speech detected for the configured duration.  The `audio_start_ms` and `audio_end_ms` fields indicate the segment of audio after the last model response up to the triggering time, as an offset from the beginning of audio written to the input audio buffer. This means it demarcates the segment of audio that was silent and the difference between the start and end values will roughly match the configured timeout.  The empty audio will be committed to the conversation as an `input_audio` item (there will be a `input_audio_buffer.committed` event) and a model response will be generated. There may be speech that didn't trigger VAD but is still detected by the model, so the model may respond with something relevant to the conversation or a prompt to continue speaking.
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize, bon::Builder)]
pub struct RealtimeServerEventInputAudioBufferTimeoutTriggered {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
    pub event_id: String,
    /// The event type, must be `input_audio_buffer.timeout_triggered`.
    #[serde(rename = "type")]
    pub r#type: Type,
    /// Millisecond offset of audio written to the input audio buffer that was after the playback time of the last model response.
    #[serde(rename = "audio_start_ms")]
    pub audio_start_ms: i32,
    /// Millisecond offset of audio written to the input audio buffer at the time the timeout was triggered.
    #[serde(rename = "audio_end_ms")]
    pub audio_end_ms: i32,
    /// The ID of the item associated with this segment.
    #[serde(rename = "item_id")]
    pub item_id: String,
}

impl RealtimeServerEventInputAudioBufferTimeoutTriggered {
    /// Returned when the Server VAD timeout is triggered for the input audio buffer. This is configured with `idle_timeout_ms` in the `turn_detection` settings of the session, and it indicates that there hasn't been any speech detected for the configured duration.  The `audio_start_ms` and `audio_end_ms` fields indicate the segment of audio after the last model response up to the triggering time, as an offset from the beginning of audio written to the input audio buffer. This means it demarcates the segment of audio that was silent and the difference between the start and end values will roughly match the configured timeout.  The empty audio will be committed to the conversation as an `input_audio` item (there will be a `input_audio_buffer.committed` event) and a model response will be generated. There may be speech that didn't trigger VAD but is still detected by the model, so the model may respond with something relevant to the conversation or a prompt to continue speaking.
    pub fn new(
        event_id: String,
        r#type: Type,
        audio_start_ms: i32,
        audio_end_ms: i32,
        item_id: String,
    ) -> RealtimeServerEventInputAudioBufferTimeoutTriggered {
        RealtimeServerEventInputAudioBufferTimeoutTriggered {
            event_id,
            r#type,
            audio_start_ms,
            audio_end_ms,
            item_id,
        }
    }
}
/// The event type, must be `input_audio_buffer.timeout_triggered`.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Type {
    #[serde(rename = "input_audio_buffer.timeout_triggered")]
    InputAudioBufferTimeoutTriggered,
}

impl Default for Type {
    fn default() -> Type {
        Self::InputAudioBufferTimeoutTriggered
    }
}

impl std::fmt::Display for RealtimeServerEventInputAudioBufferTimeoutTriggered {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match serde_json::to_string(self) {
            Ok(s) => write!(f, "{}", s),
            Err(_) => Err(std::fmt::Error),
        }
    }
}
