/*
 * OpenAI API
 *
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * 
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

/// RealtimeServerEventOutputAudioBufferStopped : **WebRTC Only:** Emitted when the output audio buffer has been completely drained on the server, and no more audio is forthcoming. This event is emitted after the full response data has been sent to the client (`response.done`). [Learn more](https://platform.openai.com/docs/guides/realtime-conversations#client-and-server-events-for-audio-in-webrtc). 
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize, bon::Builder)]
pub struct RealtimeServerEventOutputAudioBufferStopped {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
    pub event_id: String,
    #[serde(rename = "type", deserialize_with = "Option::deserialize")]
    pub r#type: Option<serde_json::Value>,
    /// The unique ID of the response that produced the audio.
    #[serde(rename = "response_id")]
    pub response_id: String,
}

impl RealtimeServerEventOutputAudioBufferStopped {
    /// **WebRTC Only:** Emitted when the output audio buffer has been completely drained on the server, and no more audio is forthcoming. This event is emitted after the full response data has been sent to the client (`response.done`). [Learn more](https://platform.openai.com/docs/guides/realtime-conversations#client-and-server-events-for-audio-in-webrtc). 
    pub fn new(event_id: String, r#type: Option<serde_json::Value>, response_id: String) -> RealtimeServerEventOutputAudioBufferStopped {
        RealtimeServerEventOutputAudioBufferStopped {
            event_id,
            r#type,
            response_id,
        }
    }
}



impl std::fmt::Display for RealtimeServerEventOutputAudioBufferStopped {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match serde_json::to_string(self) {
            Ok(s) => write!(f, "{}", s),
            Err(_) => Err(std::fmt::Error),
        }
    }
}
