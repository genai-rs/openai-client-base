/*
 * OpenAI API
 *
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`cancel_eval_run`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelEvalRunError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_eval`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateEvalError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_eval_run`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateEvalRunError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_eval`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteEvalError {
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_eval_run`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteEvalRunError {
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_eval`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEvalError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_eval_run`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEvalRunError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_eval_run_output_item`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEvalRunOutputItemError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_eval_run_output_items`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEvalRunOutputItemsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_eval_runs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEvalRunsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_evals`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListEvalsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_eval`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateEvalError {
    UnknownValue(serde_json::Value),
}


/// Cancel an ongoing evaluation run. 
#[bon::builder]
pub async fn cancel_eval_run(configuration: &configuration::Configuration, eval_id: &str, run_id: &str) -> Result<models::EvalRun, Error<CancelEvalRunError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_eval_id = eval_id;
    let p_path_run_id = run_id;

    let uri_str = format!("{}/evals/{eval_id}/runs/{run_id}", configuration.base_path, eval_id=crate::apis::urlencode(p_path_eval_id), run_id=crate::apis::urlencode(p_path_run_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EvalRun`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EvalRun`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CancelEvalRunError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create the structure of an evaluation that can be used to test a model's performance. An evaluation is a set of testing criteria and the config for a data source, which dictates the schema of the data used in the evaluation. After creating an evaluation, you can run it on different models and model parameters. We support several types of graders and datasources. For more information, see the [Evals guide](https://platform.openai.com/docs/guides/evals). 
#[bon::builder]
pub async fn create_eval(configuration: &configuration::Configuration, create_eval_request: models::CreateEvalRequest) -> Result<models::Eval, Error<CreateEvalError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_create_eval_request = create_eval_request;

    let uri_str = format!("{}/evals", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_create_eval_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Eval`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Eval`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateEvalError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Kicks off a new run for a given evaluation, specifying the data source, and what model configuration to use to test. The datasource will be validated against the schema specified in the config of the evaluation. 
#[bon::builder]
pub async fn create_eval_run(configuration: &configuration::Configuration, eval_id: &str, create_eval_run_request: models::CreateEvalRunRequest) -> Result<models::EvalRun, Error<CreateEvalRunError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_eval_id = eval_id;
    let p_body_create_eval_run_request = create_eval_run_request;

    let uri_str = format!("{}/evals/{eval_id}/runs", configuration.base_path, eval_id=crate::apis::urlencode(p_path_eval_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_create_eval_run_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EvalRun`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EvalRun`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateEvalRunError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete an evaluation. 
#[bon::builder]
pub async fn delete_eval(configuration: &configuration::Configuration, eval_id: &str) -> Result<models::DeleteEval200Response, Error<DeleteEvalError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_eval_id = eval_id;

    let uri_str = format!("{}/evals/{eval_id}", configuration.base_path, eval_id=crate::apis::urlencode(p_path_eval_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteEval200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteEval200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteEvalError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete an eval run. 
#[bon::builder]
pub async fn delete_eval_run(configuration: &configuration::Configuration, eval_id: &str, run_id: &str) -> Result<models::DeleteEvalRun200Response, Error<DeleteEvalRunError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_eval_id = eval_id;
    let p_path_run_id = run_id;

    let uri_str = format!("{}/evals/{eval_id}/runs/{run_id}", configuration.base_path, eval_id=crate::apis::urlencode(p_path_eval_id), run_id=crate::apis::urlencode(p_path_run_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteEvalRun200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteEvalRun200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteEvalRunError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get an evaluation by ID. 
#[bon::builder]
pub async fn get_eval(configuration: &configuration::Configuration, eval_id: &str) -> Result<models::Eval, Error<GetEvalError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_eval_id = eval_id;

    let uri_str = format!("{}/evals/{eval_id}", configuration.base_path, eval_id=crate::apis::urlencode(p_path_eval_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Eval`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Eval`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEvalError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get an evaluation run by ID. 
#[bon::builder]
pub async fn get_eval_run(configuration: &configuration::Configuration, eval_id: &str, run_id: &str) -> Result<models::EvalRun, Error<GetEvalRunError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_eval_id = eval_id;
    let p_path_run_id = run_id;

    let uri_str = format!("{}/evals/{eval_id}/runs/{run_id}", configuration.base_path, eval_id=crate::apis::urlencode(p_path_eval_id), run_id=crate::apis::urlencode(p_path_run_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EvalRun`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EvalRun`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEvalRunError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get an evaluation run output item by ID. 
#[bon::builder]
pub async fn get_eval_run_output_item(configuration: &configuration::Configuration, eval_id: &str, run_id: &str, output_item_id: &str) -> Result<models::EvalRunOutputItem, Error<GetEvalRunOutputItemError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_eval_id = eval_id;
    let p_path_run_id = run_id;
    let p_path_output_item_id = output_item_id;

    let uri_str = format!("{}/evals/{eval_id}/runs/{run_id}/output_items/{output_item_id}", configuration.base_path, eval_id=crate::apis::urlencode(p_path_eval_id), run_id=crate::apis::urlencode(p_path_run_id), output_item_id=crate::apis::urlencode(p_path_output_item_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EvalRunOutputItem`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EvalRunOutputItem`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEvalRunOutputItemError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of output items for an evaluation run. 
#[bon::builder]
pub async fn get_eval_run_output_items(configuration: &configuration::Configuration, eval_id: &str, run_id: &str, after: Option<&str>, limit: Option<i32>, status: Option<&str>, order: Option<&str>) -> Result<models::EvalRunOutputItemList, Error<GetEvalRunOutputItemsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_eval_id = eval_id;
    let p_path_run_id = run_id;
    let p_query_after = after;
    let p_query_limit = limit;
    let p_query_status = status;
    let p_query_order = order;

    let uri_str = format!("{}/evals/{eval_id}/runs/{run_id}/output_items", configuration.base_path, eval_id=crate::apis::urlencode(p_path_eval_id), run_id=crate::apis::urlencode(p_path_run_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EvalRunOutputItemList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EvalRunOutputItemList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEvalRunOutputItemsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of runs for an evaluation. 
#[bon::builder]
pub async fn get_eval_runs(configuration: &configuration::Configuration, eval_id: &str, after: Option<&str>, limit: Option<i32>, order: Option<&str>, status: Option<&str>) -> Result<models::EvalRunList, Error<GetEvalRunsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_eval_id = eval_id;
    let p_query_after = after;
    let p_query_limit = limit;
    let p_query_order = order;
    let p_query_status = status;

    let uri_str = format!("{}/evals/{eval_id}/runs", configuration.base_path, eval_id=crate::apis::urlencode(p_path_eval_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EvalRunList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EvalRunList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEvalRunsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List evaluations for a project. 
#[bon::builder]
pub async fn list_evals(configuration: &configuration::Configuration, after: Option<&str>, limit: Option<i32>, order: Option<&str>, order_by: Option<&str>) -> Result<models::EvalList, Error<ListEvalsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_after = after;
    let p_query_limit = limit;
    let p_query_order = order;
    let p_query_order_by = order_by;

    let uri_str = format!("{}/evals", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order_by {
        req_builder = req_builder.query(&[("order_by", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EvalList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EvalList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListEvalsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update certain properties of an evaluation. 
#[bon::builder]
pub async fn update_eval(configuration: &configuration::Configuration, eval_id: &str, update_eval_request: models::UpdateEvalRequest) -> Result<models::Eval, Error<UpdateEvalError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_eval_id = eval_id;
    let p_body_update_eval_request = update_eval_request;

    let uri_str = format!("{}/evals/{eval_id}", configuration.base_path, eval_id=crate::apis::urlencode(p_path_eval_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_update_eval_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Eval`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Eval`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateEvalError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

